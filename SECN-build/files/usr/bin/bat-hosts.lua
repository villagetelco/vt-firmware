#!/usr/bin/lua

local type_id = 64  -- bat-hosts
local announce_id = 65

function split(str, delim, maxNb)
    -- Eliminate bad cases...
    if string.find(str, delim) == nil then
        return { str }
    end
    if maxNb == nil or maxNb < 1 then
        maxNb = 0    -- No limit
    end
    local result = {}
    local pat = "(.-)" .. delim .. "()"
    local nb = 0
    local lastPos
    for part, pos in string.gfind(str, pat) do
        nb = nb + 1
        result[nb] = part
        lastPos = pos
        if nb == maxNb then break end
    end
    -- Handle the last field
    if nb ~= maxNb then
        result[nb + 1] = string.sub(str, lastPos)
    end
    return result
end

function get_hostname()
  local hostfile = io.open("/proc/sys/kernel/hostname", "r")
  local ret_string = hostfile:read("*a")
  ret_string = string.gsub(ret_string, "\n", "")
  hostfile:close()
  return ret_string
end

function get_interfaces_names()
  local i, ret
  i = 0
  ret = {}
  for name in io.popen("ls -1 /sys/class/net/"):lines() do
    if name ~= "lo" then
      i = i + 1
      ret[i] = name
    end
  end

  return ret
end

function get_interface_address(name)
  local addressfile = io.open("/sys/class/net/"..name.."/address", "r")
  local ret_string = addressfile:read("*a")
  ret_string = string.gsub(ret_string, "\n", "")
  addressfile:close()
  return ret_string
end

function get_lan_ip_address()
  local proc = io.popen("ifconfig br-lan")
  local data = proc:read("*a")
  local ipaddr = data:match("addr%:(%d+%.%d+%.%d+%.%d+)")
  return ipaddr
end

local function generate_bat_hosts()
-- get hostname and interface macs/names
-- then return a table containing valid bat-hosts lines
  local n, i
  local ifaces, ret = {}, {}

  --local hostname = nxo.uname().nodename
  local hostname = get_hostname()

  -- skip loopback ("lo") mac (00:00:00:00:00:00)
  for n, i in ipairs(get_interfaces_names()) do
    local address = get_interface_address(i)
    ifaces[address] = i
  end

  for mac, iname in pairs(ifaces) do
    table.insert(ret, mac.." "..hostname.."_"..iname.."\n")
  end

  return ret
end

local function publish_bat_hosts()
-- pass a raw chunk of data to alfred
  local fd = io.popen("alfred -s " .. type_id, "w")
  if fd then
    local ret = generate_bat_hosts()
    if ret then
      fd:write(table.concat(ret))
    end
    fd:close()
  end
end

local function write_bat_hosts(rows)
  local content = { "### File generated by alfred-mod-bat-hosts\n" }

  -- merge the chunks from all nodes, de-escaping newlines
  for _, row in ipairs(rows)  do
    local node, value = unpack(row)
    table.insert(content, "# Node ".. node .. "\n")
    table.insert(content, value:gsub("\x0a", "\n") .. "\n")
  end

  -- write parsed content down to disk
  local fd = io.open("/tmp/bat-hosts", "w")
  if fd then
    fd:write(table.concat(content))
    fd:close()
  end
end

local function write_bat_hosts_json(rows)
  local content = { "{\n" }

  -- merge the chunks from all nodes, de-escaping newlines
  for i, row in ipairs(rows)  do
    local node, value = unpack(row)

    -- Split the lines into rows
    local split_rows = split(value, "\x0a")

    -- Remove blank from the end otherwise errors
    if split_rows[table.getn(split_rows)] == "" then
      table.remove(split_rows)
    end

    -- Loop through the new rows
    for j, val in ipairs(split_rows) do
      local split_value = split(val, " ")

      -- Get the hostname and the interface name from the name given
      local hName, iface = split_value[2]:match("([^_]*)_(%S*)")
  
      local json_row = '"'..split_value[1]..'": {\"hName\": "'..hName..'", \"iface\": "'..iface..'"}'

      -- Check if it's the last row to make sure not to add the , 
      if i == table.getn(rows) and j == table.getn(split_rows) then
        json_row = json_row.."\n}\n"
      else
        json_row = json_row..",\n"
      end

      table.insert(content, json_row)
    end
  end

  -- write parsed content down to disk
  local fd = io.open("/www/log/bathosts_log.json", "w")
  if fd then
    fd:write(table.concat(content))
    fd:close()
  end
end

local function receive_bat_hosts()
-- read raw chunks from alfred, convert them to a nested table and call write_bat_hosts

  local fd = io.popen("alfred -r " .. type_id)
    --[[ this command returns something like
    { "54:e6:fc:b9:cb:37", "00:11:22:33:44:55 ham_wlan0\x0a00:22:33:22:33:22 ham_eth0\x0a" },
    { "90:f6:52:bb:ec:57", "00:22:33:22:33:23 spam\x0a" },
    ]]--

  if fd then
      local output = fd:read("*a")
      if output then
        assert(loadstring("rows = {" .. output .. "}"))()
        write_bat_hosts_json(rows)
      end
      fd:close()
  end
end

function publish_announce()
  local pid_file = io.open("/var/run/dmtf_scan.pid", "r")

  if pid_file == nil then
    return
  end

  pid_file:close()

  local fd = io.popen("alfred -s " .. announce_id, "w")

  if fd == nil then
    return
  end

  fd:write("ip:" .. get_lan_ip_address() .. "|host:" .. get_hostname())

  fd:close()
end

function receive_announce()
  local announce_file = io.open("/www/log/announce_log.json", "w")

  local announce_string = "{\"hosts\":["

  local has_hosts = 0

  for data in io.popen("alfred -r " .. announce_id):lines() do
    has_hosts = 1
    local ipaddr, hostname = data:match("ip%:(%d+%.%d+%.%d+%.%d+)|host%:([^%\"]*)")
    announce_string = announce_string .. string.format("\n{\"ipaddr\":%q,\"hostname\":%q},", ipaddr, hostname)
  end

  if has_hosts == 1 then
    announce_string = announce_string:sub(0, announce_string:len() - 1)
  end
  
  announce_string = announce_string .. "\n]}"
  
  announce_file:write(announce_string)
  announce_file:close()
end

publish_bat_hosts()
receive_bat_hosts()

publish_announce()
receive_announce()